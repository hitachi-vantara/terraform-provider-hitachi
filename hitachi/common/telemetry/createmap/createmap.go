// createmap.go
//
// This Go program is intended to be used at build time to generate a telemetry
// map of Terraform resource and data source registrations from provider.go.
// It parses the ResourcesMap and DataSourcesMap defined in the provider,
// and creates a corresponding Go source file (`terraform_provider_map.go`) that
// contains a map[string]string called `TerraformProviderMap`.
//
// The generated map is used for telemetry, debugging, or mapping Terraform
// schema elements back to their function or module origin.
//
// Usage:
//   from main dir:
//   go run createmap.go
//
// Notes:
// - This tool assumes consistent naming conventions in the provider map keys.
// - Prefixes like `san` or `vosb` are inferred based on the Terraform names.
// - This script should be run as part of the provider build pipeline.

package main

import (
	"bufio"
	"fmt"
	"os"
	"regexp"
	"sort"
	"strings"
)

type entry struct {
	key   string
	value string
}

func main() {
	inputFile := "hitachi/terraform/provider.go"
	outputFile := "hitachi/common/telemetry/terraform_provider_map.go"

	file, err := os.Open(inputFile)
	if err != nil {
		panic(err)
	}
	defer file.Close()

	var entries []entry
	scanner := bufio.NewScanner(file)

	resourceRegex := regexp.MustCompile(`"([^"]+)":\s+resourceimpl\.(\w+)\(\)`)
	dataSourceRegex := regexp.MustCompile(`"([^"]+)":\s+datasourceimpl\.(\w+)\(\)`)

	// Add ProviderConfigure mappings
	entries = append(entries,
		entry{"san.terraform.ProviderConfigure", "san.terraform.providerConfigure"},
		entry{"vosb.terraform.ProviderConfigure", "vosb.terraform.providerConfigure"},
		entry{"vsp_one.terraform.ProviderConfigure", "vsp_one.terraform.providerConfigure"},
	)

	inBlockComment := false

	for scanner.Scan() {
		line := scanner.Text()
		trimmed := strings.TrimSpace(line)

		// --- Handle comments ---
		// Detect start or end of block comment
		if strings.Contains(trimmed, "/*") {
			inBlockComment = true
		}
		if inBlockComment {
			if strings.Contains(trimmed, "*/") {
				inBlockComment = false
			}
			continue
		}

		// Skip single-line comments
		if strings.HasPrefix(trimmed, "//") || trimmed == "" {
			continue
		}

		// Remove inline comments (e.g., trailing // text)
		if idx := strings.Index(trimmed, "//"); idx != -1 {
			trimmed = strings.TrimSpace(trimmed[:idx])
		}

		// Skip if line became empty after removing comment
		if trimmed == "" {
			continue
		}

		// Match Resources
		if match := resourceRegex.FindStringSubmatch(trimmed); match != nil {
			tfName := match[1]
			funcName := match[2]
			prefix := "san"
			if strings.HasPrefix(tfName, "hitachi_vosb_") {
				prefix = "vosb"
			} else if strings.HasPrefix(tfName, "hitachi_vsp_one_") {
				prefix = "vsp_one"
			}
			entries = append(entries, entry{
				key:   fmt.Sprintf("%s.resource.%s", prefix, funcName),
				value: fmt.Sprintf("%s.resource.%s", prefix, tfName),
			})
			continue
		}

		// Match Data Sources
		if match := dataSourceRegex.FindStringSubmatch(line); match != nil {
			tfName := match[1]
			funcName := match[2]
			prefix := "san"
			if strings.HasPrefix(tfName, "hitachi_vosb_") {
				prefix = "vosb"
			} else if strings.HasPrefix(tfName, "hitachi_vsp_one_") {
				prefix = "vsp_one"
			}
			entries = append(entries, entry{
				key:   fmt.Sprintf("%s.datasource.%s", prefix, funcName),
				value: fmt.Sprintf("%s.datasource.%s", prefix, tfName),
			})
			continue
		}
	}

	// Determine the longest key length for alignment
	maxKeyLen := 0
	for _, e := range entries {
		if len(e.key) > maxKeyLen {
			maxKeyLen = len(e.key)
		}
	}

	// Sort entries alphabetically by key for consistency
	sort.Slice(entries, func(i, j int) bool {
		return entries[i].key < entries[j].key
	})

	// Build file content
	var lines []string
	lines = append(lines, "// Code generated by createmap.go â€” DO NOT EDIT.")
	lines = append(lines, "package telemetry\n")
	lines = append(lines, "var TerraformProviderMap = map[string]string{")

	for _, e := range entries {
		padding := strings.Repeat(" ", maxKeyLen-len(e.key))
		lines = append(lines, fmt.Sprintf(`	"%s"%s: "%s",`, e.key, padding, e.value))
	}

	lines = append(lines, "}")

	// Write to file
	err = os.WriteFile(outputFile, []byte(strings.Join(lines, "\n")+"\n"), 0644)
	if err != nil {
		panic(err)
	}

	fmt.Println("telemetry map file generated successfully.")
}
